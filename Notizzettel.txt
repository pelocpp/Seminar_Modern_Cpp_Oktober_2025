====================================================

Seminar "Modern C++"
--------------------

Guten Morgen

Peter Loos

peter.loos@gmx.de
-----------------

30+ Jahre: SW-Entwicklung // Training

Fortran, Pascal, C/C++, Java, C#, JavaScript, Mobile Programming

Back-to-Roots: C++

====================================================

Unterlagen:

https://github.com/pelocpp

https://github.com/pelocpp/cpp_modern

Zusätzlich:

Datei Seminar_STL_Container.cpp
Datei Seminar_STL_Container_02.cpp

===================================================


Python: Dictionary

Hash-Tabelle:  Morgen ...


====================================================


12.30 - 13.30

Von 9 bis bis 17 Uhr

Pausen vor und nachmittags

Übungen: Schaun mer Mal ...

// Dienstag: Vormittagspause: 10.30 - 11 Uhr 

====================================================

2 Tools:

a) Visual Studio

b) Github

====================================================

Roter Faden ==> Agenda

Vorstellungsrunde:

== Was sind meine Erwartungen?
== Überblick // mach mal Alles?
== Was MUSS drin sein?
== Vemisse ich etwas in der Agenda?
== Feedback
== Welche Sprachen bringe ich mit ?
== Multithreading: Ja oder Nein.

== Classic C++ ===> Modern C++
== Überblick

====================================================

Mythos:  

Visual Studio: For Free

Visual Studio Community 2022

====================================================

== RValues
== Move-Semantik

Begrifflichkeiten:

LValue
RValue

a = b;   // Links: a:  Adresse von a // LValue
         // Rechts: b: Adresse von b, um an den WERT zu kommen. // RValue

a = 123 * 456;  // Rechts: WERT (konstant) // RValue

Vor C++ 11 haben wir mit temp. Objekten ein PROBLEM:

Diese werden im Regelfall KOPIERT.

Abhilfe:

Referenz:

a) Klassische Referenz: Objekte mit NAMEN // LValue-Referenz

int n = 123;

int& ri = n;

b) Ab C++ 11: Weiteren Referenztyp: RValue-Referenz

int&& ri = 123;


Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy  => Move-Semantik

Was hat es mit dem "Namen" auf sich ??????????????

=============================================================

Whyyyyyyy ???   => Move-Semantik (C++ 11)

..: ... 240   // tmp. Objekt am Stack // wird freigegeben
..: ... 390   // Ist im Vektor

..: ... 710   // tmp. Objekt am Stack

i) Mit Hilfe von RValues kann man tmp. Objekte DIREKT ansprechen.
ii) Mit Verschieben kann man PERFORMANT Inhalte von Objekten
    von a) nach b) bewegen.

Offene Punkte:

a) Kopier-Konstruktor ===> Damit ich eine echte Kopie bekomme.

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/RuleOfThree.md

b) Was ist das ECHTE Problem, wenn der Kopier-Konstruktor NICHT
   vorhanden ist?

   ... 1d0

   Double-Delete ==> Echtem Kopier-Konstruktor !!!

======================================================

STL // Container ...

C++:  Standard Bibliothek

Templates 

C++:  Standard Template Bibliothek

// C Standard Array: FIXED Size  : int numbers [100];

Variable Sized: std::vector

Neue interne Länge = alte interne Länge * 1.5;

Verwende resize (!!!!!), um Umkopieren zu minimieren !!!

========================================================

STL:  Design Prinzipien
-----------------------

Homogenes // ähnliches Aussehen, ähnlicher Zugriff , im Arbeiten
mit allen unterschiedlichen STL-Containern.

STL-Container:

Vektor: Flexibel langes Array

Baumstrukturen:  std::map

Hash-Tabellen:   std::ordered_map     // Python: Dictionary

Listen: Verkettete Liste  // std::list 

Beispiel: Baumstruktor

std::tree myTree;

myTree[3] = 123;  // operator[] hat KEINEN Sinn !!!

Beispiel:   Verkettete Liste 



list[2] = 123;   // Gewalt implementieren können  // Was ist,
                 // wenn Index zu groß

Das tut man nicht: Why ???

STL implementiert nur PERFORMANTE Algorithmen

======================================

Index-Operator: Eignet sich nur sequentielle Container:

std::vector
std::array

Anderes Konzept für NICHT-sequentielle Container

==> Iterator:  

Was ist ein Iterator: Beschreibt eine POSITION in einem Container.

STL:

== Container
== Iterator (Position)
== Algorithmus // Kleine Helfer-Methoden für Container
== Aufrufbare Objekte

Nebenfrage:

static void output(int elem)          // Wert kopiert
{
    std::println("{}", elem);
}

oder

static void output(const int& elem)   // Übergabe einer Referenz
{
    std::println("{}", elem);
}

Frage: Egal oder nicht egal.

Zugriff via Kopie:

    int m = elem;
00007FF77A0830A0  mov         eax,dword ptr [elem]     // direkter Variablenzugriff
00007FF77A0830A6  mov         dword ptr [m],eax  

Zugriff via Referenz (Pointer): 

    int m = elem;
00007FF68E3330A1  mov         rax,qword ptr [elem]     // INDIREKTER Variablenzugriff
00007FF68E3330A8  mov         eax,dword ptr [rax]  
00007FF68E3330AA  mov         dword ptr [m],eax  

Tut der Compiler das nicht optimieren ???

Ja, ist möglich.

Wie werden Parameter an Funktionen übergeben: 

a) Am Stack.

b) Via Register.

Beobachtung:

Debug-Code und Release-Mode (optimierter Code) können
SEHR unterschiedlich sein !!!

// ==========================================

Aufrufbare Objekte:

Eine Klasse, die den Operator operator() implementiert.

Anderer Name: Callable, Funktor 

// ==========================================

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

C++:   Bjarne Stroustrup  // C with Classes

       Alexander Stepanov: generische Programmierung

       Idee: C++: Bibliothek (STL)

  ==> Idiom: C++ ist eine objekt-orientierte Sprache
  ==> Idiom: C++ ist eine generische Sprache (Templates)

generische Programmierung:

template <typename T>  // T gleich int or long or long long
bool evaluateValue (T value)
{
   
}

==> flexibler zu entwickeln // unabhängiger 

// ==================================================

class Person
{
    public:
}


... 6A0

... 390   .. im Person Objekt

... 4E0

====================================

... 2B0    // hans

... 0F0    // im Person Objekt

... 0F0    // selbe Adresse in n


====================================

C++ ist eine der schwierigsten Programmiersprachen
--------------------------------------------------

Lambdas
-------

==> Gebrauchsanweisung: No

==> Blick hinter den Kulisse: Yes

Wie: Tool:  Cpp Insights

Kein Online-Compiler, sondern ein Umsetzer:

Modern C++ ===> Classic C++


std::sort

Kriterium des Vergleichs:

a) freie Funktion

b) Aufrufbares Objekt

   OO

c) Lambda - Syntax

==============================================

Hinweis:

Salopp formuliert:

   Lambda - Funktion

Bitte, wenn es genau sein muss:

Ein Lambda ist ein OBJEKT !!!!!!!!!!! 
Ein Lambda ist eine Instanz einer Klasse, die den Operator operator() implementiert !!!!!!!!!!! 

==============================================

Lambdas und lokale Variablen der umgebenden Funktion.

==============================================

Ein Lambda ist ein Objekt.

Was haben Objekte? ==> Methoden und Instanzvariablen



Touch der funktionalen Programmierung:

==> Funktionen an Funktionen übergeben werden.

=====================================================

C++ versucht am Ball zu bleiben ...

Sie läuft hinter den anderen Sprachen her ...

"anderen Sprachen":  for_each

// JavaScript
for_each ( var elem   : container  ) {

}

Okay , warum nicht ...

Designer: Neue Schlüsselwörter for_each : No.

======================================================

Initialisierung:

Neustart => Änderungen an der Syntax

Klasse Point

== Point p(1, 2);

== Point p{ 1, 2 };

Soll ich umstellen?   Nein.

Neuer Entwicklung:    Vielleicht doch // einheitlich.

Beachte:

Visual C++:

Es gibt Bit-Muster für NICHT initialisierten Speicherbereich !!!

Stack: CC

Heap:  DD (?)
Heap:  CD (?), wenn der Speicher freigegen worden ist     


// ================================================================

std::initializer_list

C++ 11: Neuer Helfer

Ablage der Daten:

std::vector                ===> Daten: HEAP
std::initializer_list      ===> Daten: STACK

==> Ablage am Stack PERFORMANTER als am Heap

Bemerkung:

std::initializer_list ist kein vollwertiger STL-Container.

Lightweight Container // Leichtgewichtiger Container

3 Methoden:

begin()
end()
size()

Manko:

std::vector<int> vec1( 10 );  // Size: 10, Werte: Zehn mal 0 vorbelegt
std::vector<int> vec2{ 10 };  // Size: 1,  Werte: 10 vorbelegt

Das Spiel wiederholt sich ...

std::string s (10, '*');   ==> "**********"

std::string s {10, '*'};   ==> "**********"

=======================================================

C++: Keine IDE installieren ...

Schnell ausprobieren ....

Online Compiler

https://wandbox.org/

Beispiel:

#include <string>
#include <print>

static void test_frage()
{
    std::string s1{ 66, '*' };
    std::string s2( 10, '*' );

    std::println ("{}", s1);
    std::println ("{}", s2);
}

int main()
{
    test_frage();
}


Übung:

Aufgabe 1:

Move-Semantik ==> Aufgabe 1	Verschiebe-Semantik am Beispiel einer benutzerdefinierten Klasse

Lambda-Funktionen:


Big-Five:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/MoveSemantics/MoveSemantics.md

==>

Option:  Pause .......

Option: Stürtzt in die Übung .....

===============================================

Intelligente Zeiger (Smart Pointer)

int* ip = new int[10];

...

// delete[] ip;

Was ist das Problem von new / delete ????

Fehlende deletes

Suche nach fehlende deletes:  Todesmarsch  // Death March (Ed Yourdon)

Neuen Art und Weise des Umgangs mit new / delete:  Versteckt.

==> Hüllenklassen // Wrapper ???????

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

Klassen // Objekten // OO

-- Konstruktoren
-- Destruktoren

Wann wird ein Destruktor aufgerufen ??? 

== Am Ende eines Blocks // Scope (Gültigkeitsbereich)
== Der Aufruf ist DETERMINISTISCH; der kann nicht verloren gehen
== es gibt keine fehlenden Destruktoren

Idee / Trick:

Man übergibt einen Zeiger (int*) in die Obhut eines Objekts:
==> Im Destruktor ist das delete platziert / vorhanden.

Frage: Wie kann man so ein Objekt im Programm weiterreichen 
       Wie kann man so eine Objekt aus einem Bereich / Block weiterschleusen.


Wann stellt der Compiler das fest ???

Programmstruktur:  Block 

a) Funktion

void func()
{
    Person p;
    ...
}   <======== Destruktor


b) Funktion

void func()
{
    ...

    while ()
    {
        Person p;
        ....
    }   <======== Destruktor p

    // hier ist p nicht mehr vorhanden

}


c) Funktion

void func()
{
    ...

    // innerer, geschachtelter Block
    {
        Person p;
        ....
    }   <======== Destruktor p

    // hier ist p nicht mehr vorhanden

}

A) Historisch: Klasse auto_ptr. // deprecated

B) std::unique_ptr
   std::shared_ptr / std::weak_ptr

Unterschiedliche Strategien:

i) std::unique_ptr:

   Zu einem Zeitpunkt im Programmablauf kann ein std::unique_ptr-Objekt
   nur EINEN Besitzer haben.

   ==> Ein std::unique_ptr-Objekt ist NICHT kopierbar.

   Uniqueness: ===> Verschieben (von A nach B) geht

   Frage: Wie kann man so ein Objekt im Programm weiterreichen 
   Wie kann man so eine Objekt aus einem Bereich / Block weiterschleusen.


ii) std::shared_ptr

   Zu einem Zeitpunkt im Programmablauf kann ein std::shared_ptr-Objekt
   mehrere EINEN Besitzer haben.

   Zu klären: Wann wird delete aufgerufen.

   Rolle des Destruktors:  Der Referenzzähler ist zu aktualisieren.

   3 => 2 => 1 => 0: Jetzt wird delete aufgerufen.

Frage:

 std::make_shared   : ist performanter .............
 std::make_unique

 verwenden oder nicht: Doch, verwenden ...

---------------------------

std::shared_ptr:

Beobachtung:  std::shared_ptr funktioniert nicht immer :)

????????????????????????  Whyyyyyyyyyyyyyyyyyyyyy

std::weak_ptr

a) Technik der std::weak_ptr Klasse
b) Problem ???

Nachgestellte Fragen:

i)  Zyklen habe ich in meiner SW nicht.
ii) Was ist das tatsächliche Problem eines Zyklusses ???

    Antwort: Bilder malen


Frage:

Beispiel: Observer-Pattern 

Beobachter - Pattern:

a) Zentrales Objekt, das seinen Zustand ändert (Wetterdaten, Aktienkurse)

   Nomenklatur: Event Source, Subject, Observable

b) Beobachter: Event Client // Observer

c) Damit ein Beobachter Nachrichten von der Event Source erhalten kann,
   muss er sich dort anmelden.

   Observer ==> Kennt Event Source

d) Event Source: Ruft eine Methode bei den Event Clients (Observer) auf,
   wenn sich am Zustand etwas ändert.

   Event Source ===> Kennt Observer

Bilder:

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/Observer/Resources/Readme.md

std::shared_ptr:
std::weak_ptr:

i) Event Source ==> std::shared_ptr

ii) Beobachter: ==> std::shared_ptr

iii) Diese Liste aller Beobachter in der Event Source (attach/ detach):

    std::vector<std::shared_ptr>  ODER std::vector<std::weak_ptr> 

    ==> Kann oder sollte eine Event Source zum BESITZER (OWNER)
        eines Beobachters werden ????????? NEIN !!!

        std::vector<std::weak_ptr> 

        Problem // Beobachtung:

        Es wird diese Liste mit den std::weak_ptr traversiert.

        Es kommt zu einem lock Aufruf
        Es kommt zu einem EMPTY std::shared_ptr:  So What

        Ignoriert dieses Objekt

Ursprung: Ein std::shared_ptr-Objekt ist ein BESITZER !!!

Ein std::weak_ptr möchte auf einen Besitzer zugehen // dort anklopfen:
Legitim // Erlaubt // Abgewiesen werden.

== std::shared_ptr (BESITZER) ==> Referenzzähler geht hoch
== UND std::weak_ptr

================================================

Ist das mit dem Zyklus ein reines C++ Problem ???
Nein.

a) C#  // Delegates / Events: ++, --

   wenn ein Event Handler mit -- nicht abgemeldet wird,
   verbleibt dieser im Speicher.

b) Java:

   WeakReference<T>   ähnlich zu std::weak_ptr in C++

Fazit:

a) Legacy-SW:  "Klassische" Zeiger  

       ==> Smart Pointer umstellen ??? Nicht zwingend

       Never change a running System.

b) Ein neues SW-Modul wird entwickelt:

       ==> Smart Pointer einsetzen ??? Jepp, würde ich machen

       7-14 Tage, um mit Smart Pointer

       Wie lange will ich diese Objekte im Speicher halten
       (Besitzer, Owner, delete)

    Klassische Problem: double delete // Können nicht auftreten .

Go for Smart Pointer 

======================================================

Embedded: 

Objekte leben bis zum ausschalten.

a) Objekte werden nach dem Hochlauf / im Hochlauf erstellt.

b) Leben die gesamte Laufzeit des Programms (bis zum Strom-Aus).

   Offensichtlich reicht der Speicher aus.

c) Dann müssen derartige Objekt nicht ZWINGEND freigegeben werden.

d) Wozu: Ein dynmisches Objekt hat einen Vorteil:
   Man kann seinen Speicher freigeben wenn es nicht mehr benötigt wird.

Es geht einzig und alleine um die Frage: Reicht der Speicher ???

Zweite Frage:

Weiß ich die exakte Anzahl der Objekte, die ich zur Laufzeit benötige ???
Globales Datensegment.

Smart Pointer // new: Vorteil:

Ich kann zusätzlich ZUR LAUFZEIT Objekte anlegen.
Deren Anzahl ist dann frei wählbar // berechenbar.

new: 2. Vorteil: Mit delete kann man das new rückgängig machen.

YAGNI:  You ain't gonna need it -  !!!

KISS:   Keep it simple !!!

Objektverwaltung - ist nicht ganz einfach.

Reicht der Speicher ???

Bare-Metal Programming:

  Ohne Betriebssystem.

  ===> HW // Firmware // IO // Interrupts

Desktop-Anwendung:

=================================================

constexpr

Embedded: interessant sein.

constexpr: Vermutung: Ist ähnlich zu const - FALSCH !!!

        constexpr Complex c3 = c1 + c2;
00007FF72408C180  movss       xmm0,dword ptr [__real@40800000 (07FF7242B9FE0h)]  
00007FF72408C188  movss       dword ptr [c3],xmm0  
00007FF72408C190  movss       xmm0,dword ptr [__real@40a00000 (07FF7242B9FE4h)]  
00007FF72408C198  movss       dword ptr [rbp+8Ch],xmm0  


        /*constexpr*/ Complex c3 = c1 + c2;
00007FF6BDE3BF0F  lea         r8,[c2]  
00007FF6BDE3BF13  lea         rdx,[c3]  
00007FF6BDE3BF1A  lea         rcx,[c1]  
00007FF6BDE3BF1E  call        ConstExprComplex::Complex::operator+ (07FF6BDD9EEFAh)  

============================================================

STL:

Bibliothek ==> Einstieg


Es werden die folgenden STL-Algorithmen
an Hand von einfachen Beispielen vorgestellt:

std::fill
std::for_each
std::generate
std::iota
std::copy
std::transform
std::accumulate
std::sort
std::find
std::is_sorted
std::binary_search
std::none_of
std::all_of
std::any_of
std::count
std::equal_range
std::distance
std::min
std::max
std::clamp
std::minmax_element

warning C4834:
discarding return value of function with [[nodiscard]] attribute


=======================================================

Attribute

[[ deprecated ]]  

Veraltet: 

Zu einer neuen Funktion wechseln.

Wie schaffe ich es, dass euer Kollegen/innen die alte 
Funktion NICHT mehr verwenden.



warning C4834: discarding return value of function with [[nodiscard]] attribute

=======================================================

Wie lassen sich Daten ablegen ???

"Der Reihe nach / hintereinander" im Speicher liegen.

==> Zugriff ist effizient - Index - Skalieren ...

Zur Architektur von Containern (STL):

https://github.com/pelocpp/cpp_clean_performant_secure/blob/master/Clean_Performant_Code/Data_Structures_and_Algorithms/Readme_Data_Structures_and_Algorithms.md

=================================

Kernintention der STL:

Transparenz // leichte Austauschbarkeit von Containern und Algorithmen.

Hmmm, wenn wir von sequentiellen Containern (Array. Vektor)
zu assoziativen Containern wechseln, geht die Transparenz
"ein wenig" verloren :)

=================================

Assoziative Container werden in der Informatik

auch assoziative Arrays oder Maps oder Dictionaries oer Hash Tabellen genannt.


Beispiel:

A) Telefonbuch

Besteht aus Namen und Nummern // "Müller", 1232234
                              // "Meier", 43534435


B) Lexikon zweier Sprachen:

   Deutsch // Englisch

   Schlüssel: Wert - "Haus"
   Wert:      Value - "house"


C) Auftragsverwaltung:  

   DB Bahn:
   Schlüssel:   Auftragsnummer
   Wert:        Alle Daten der Reise


Was ist das Problem, wenn ich ein  Telefonbuch aus einen
Vektor abbilden wollte ???

Laufzeit bei der Suche nach einem Eintrag:

"Meier", 43534435  ===> 1.000 Stelle

==> Suche Nr. von Meier

Muss von Anfang an jeden Namen mit "Meier" vergleichen / Suchen,
werden an der 1.000-Stelle fündig und kann dann die Nr. zurückgeben.

Ggf. , wenn der Name nicht im Tel.Buch enthalten ist: Muss bis zum Ende laufen.

Lineare Suche.

Frage: Wie dann ???????????????????????

Idee:

Man lege die Einträge (Name, Nummer) doch in einem Vektor an ...

der Länge 100

Wie komme ich dann zu dem Index: NICHT Linearen Suche.

Der Index wird BERECHNET !

Wie berechnet:

Streufunktion: "Meier" :  

77 + 65 + 105 + 65 + 72 = ca. 320 % 100 == ergibt 20

==> Index 20.

Bild:

Franz Schneider: Streufunktion ==> 1: Die Infos zu 

           Franz Schneider müssen in dem Array an der 1. Stelle abgelegt werden.

Hans Mueller: Streufunktion ==> 152: 

           Die Infos zu Hans Mueller müssen in dem Array an der 152. Stelle abgelegt werden.

Tina Meier:   Streufunktion ==> 152: 

         Ohhh, da haben wir einen Konflikt:


Dies alles hat die STL dabei:    std::unordered_map

Mappe ==> Abbildung von Name auf Nummer

Ungeordnet: ==> Die Elemente selbst sind nicht geordnet

                // Im Regelfall brauche ich das auch nicht !!!

Nomenklatur:

Eintrag:    Name, Nummer

            Schlüssel (Key)  ===> Wert (Value)   // (Key, Value) Paaren

Index wird berechnet: Streuen in einen Bereich:. streuen ==> to hash

Tabelle mit den Listen:  std::vector  :  Hash-Tabelle // Streutabelle

Länge: 100  naiv ===> Theorie für eine optimale Länge:

           tatsächliche Länge wird hinter den Kulissen berechnet


Hinweis // Fingerzeig:

Wann könnte eine Hashtabelle angezeigt sein:   Suchen ...

                          Wonach:  Schlüssel
                          Was:     Wert


========================================================

Übungsaufgabe zu Hashtabellen:

Siehe "Seminar_STL_Container_02.cpp"

Modelliere ein Wörterbuch "Deutsch => Englisch"

a) Sie muss das Objekt vom Typ std::unordered_map aussehen

b) Fügen Sie 5 Wörter mit Übersetzung ein

   "Haus" ==> "house"

c) Suchen Sie nach einem Wort: Mache eine Übersetzung

d) Gebe den Inhalt des Wörterbuchs in der Konsole aus.


===

https://wandbox.org/

